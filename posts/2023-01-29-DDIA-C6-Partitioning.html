<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2023-01-29">
<meta name="description" content="A note on chapter 6 of the book Designing Data-Intensive Applications">

<title>Minh Dang - Chapter 6 - Partitioning</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Minh Dang</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/minhdang241"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/minh-dang-60406b17b/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#chapter-6-partitioning" id="toc-chapter-6-partitioning" class="nav-link active" data-scroll-target="#chapter-6-partitioning">Chapter 6: Partitioning</a>
  <ul class="collapse">
  <li><a href="#purpose" id="toc-purpose" class="nav-link" data-scroll-target="#purpose">Purpose</a></li>
  <li><a href="#partitioning-of-key-value-data" id="toc-partitioning-of-key-value-data" class="nav-link" data-scroll-target="#partitioning-of-key-value-data">Partitioning of Key-Value Data</a>
  <ul class="collapse">
  <li><a href="#partitioning-by-key-range" id="toc-partitioning-by-key-range" class="nav-link" data-scroll-target="#partitioning-by-key-range">Partitioning by Key Range</a></li>
  <li><a href="#partitioning-by-hash-of-key" id="toc-partitioning-by-hash-of-key" class="nav-link" data-scroll-target="#partitioning-by-hash-of-key">Partitioning by Hash of Key</a></li>
  <li><a href="#skewed-workloads-and-relieving-hot-spots" id="toc-skewed-workloads-and-relieving-hot-spots" class="nav-link" data-scroll-target="#skewed-workloads-and-relieving-hot-spots">Skewed Workloads and Relieving Hot Spots</a></li>
  </ul></li>
  <li><a href="#partitioning-and-secondary-indexes" id="toc-partitioning-and-secondary-indexes" class="nav-link" data-scroll-target="#partitioning-and-secondary-indexes">Partitioning and Secondary Indexes</a>
  <ul class="collapse">
  <li><a href="#partitioning-secondary-indexes-by-document" id="toc-partitioning-secondary-indexes-by-document" class="nav-link" data-scroll-target="#partitioning-secondary-indexes-by-document">Partitioning Secondary Indexes by Document</a></li>
  <li><a href="#partitioning-secondary-indexes-by-term" id="toc-partitioning-secondary-indexes-by-term" class="nav-link" data-scroll-target="#partitioning-secondary-indexes-by-term">Partitioning Secondary Indexes by Term</a></li>
  </ul></li>
  <li><a href="#rebalancing-partitions" id="toc-rebalancing-partitions" class="nav-link" data-scroll-target="#rebalancing-partitions">Rebalancing Partitions</a>
  <ul class="collapse">
  <li><a href="#rebalancing-strategies" id="toc-rebalancing-strategies" class="nav-link" data-scroll-target="#rebalancing-strategies">Rebalancing Strategies</a></li>
  </ul></li>
  <li><a href="#glossary" id="toc-glossary" class="nav-link" data-scroll-target="#glossary">Glossary:</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Chapter 6 - Partitioning</h1>
  <div class="quarto-categories">
    <div class="quarto-category">theory</div>
    <div class="quarto-category">software_engineering</div>
    <div class="quarto-category">DDIA</div>
  </div>
  </div>

<div>
  <div class="description">
    A note on chapter 6 of the book Designing Data-Intensive Applications
  </div>
</div>


<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 29, 2023</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="chapter-6-partitioning" class="level1">
<h1>Chapter 6: Partitioning</h1>
<blockquote class="blockquote">
<p><em>partition</em> == <em>shard</em> in MongoDB, Elasticsearch, and SolrCloud == <em>region</em> in HBase == <em>tablet</em> in Bigtable == a <em>vnode</em> in Cassandra and Riak == <em>vBucket</em> in CouchBase.</p>
</blockquote>
<section id="purpose" class="level2">
<h2 class="anchored" data-anchor-id="purpose">Purpose</h2>
<p>Partitioning helps to improve scalability. A large dataset can be stored across many disks and the query load can be executed by multiple processors.</p>
</section>
<section id="partitioning-of-key-value-data" class="level2">
<h2 class="anchored" data-anchor-id="partitioning-of-key-value-data">Partitioning of Key-Value Data</h2>
<blockquote class="blockquote">
<p>A Hot spot: A partition with a disproportionately high load.</p>
</blockquote>
<section id="partitioning-by-key-range" class="level3">
<h3 class="anchored" data-anchor-id="partitioning-by-key-range">Partitioning by Key Range</h3>
<p>Assign a range of <strong>sorted keys</strong> to a partition.</p>
<p><strong>Note:</strong></p>
<p>Sorting helps to improve the performance of range queries. Yet, the key should be chosen with caution to avoid hot spots in case the application often accesses the data with close keys in the sorted order.</p>
</section>
<section id="partitioning-by-hash-of-key" class="level3">
<h3 class="anchored" data-anchor-id="partitioning-by-hash-of-key">Partitioning by Hash of Key</h3>
<p>Assign a range of hash values (hashing keys) to a partition.</p>
<p><strong>Note:</strong></p>
<p>This approach makes sure that keys are distributed evenly across partitions since it destroys the key order - after hashing, two similar keys will no longer close in the sorted order.</p>
</section>
<section id="skewed-workloads-and-relieving-hot-spots" class="level3">
<h3 class="anchored" data-anchor-id="skewed-workloads-and-relieving-hot-spots">Skewed Workloads and Relieving Hot Spots</h3>
<p>In either case, there is still a chance to suffer the celebrity issue since it does not depend on the key ranges but the key itself. To solve this problem, we can add a random element to the key. For example, adding a 2-digit decimal to the key will make the data for that key split into 100 keys. Yet, this solution comes with a performance degradation when read since we have to request data from 100 keys instead of 1. Also, not all the key needs to be split, optimally, we should detect which key has high throughput and split it.</p>
</section>
</section>
<section id="partitioning-and-secondary-indexes" class="level2">
<h2 class="anchored" data-anchor-id="partitioning-and-secondary-indexes">Partitioning and Secondary Indexes</h2>
<blockquote class="blockquote">
<p>The secondary index is used to search for occurrences of a particular value.</p>
</blockquote>
<p>The problem with secondary indexes is that they don’t neatly map to partitions.</p>
<section id="partitioning-secondary-indexes-by-document" class="level3">
<h3 class="anchored" data-anchor-id="partitioning-secondary-indexes-by-document">Partitioning Secondary Indexes by Document</h3>
<p><img src="{{ site.baseurl }}/images/eb58f064e477183561d38b8d1c0f721bf7617393.png" title="Partitioning secondary indexes by document" class="img-fluid"></p>
<p>In this approach, we create local indexes for each partition. In order words, each partition maintains its secondary indexes, covering only the documents available in that partition.</p>
<p>For example, after we create the secondary index on&nbsp;<strong>color</strong>. When a red car with ID&nbsp;<strong>306</strong>&nbsp;is added to the database, the database partition of partition 0 automatically adds the ID of 306 to the list of document IDs for the index entry <code>color:red</code>.</p>
<p>This approach adds up complexity on read. Whenever we need to query a list of cars using color, we need to send a request to all the partitions, retrieve all the data and then combine it to generate the result.</p>
</section>
<section id="partitioning-secondary-indexes-by-term" class="level3">
<h3 class="anchored" data-anchor-id="partitioning-secondary-indexes-by-term">Partitioning Secondary Indexes by Term</h3>
<p><img src="{{ site.baseurl }}/images/bc9c7d2a677ff25aa74382e6efcf6e4306558973.png" title="Partitioning secondary indexes by term" class="img-fluid"></p>
<p>In this approach, we apply the same mechanism as&nbsp;<strong>partitioning by key range or partitioning by hash of key</strong>. We create a global index covering all the data across the partitions. The global index will be partitioned by the range and stored across partitions. Now, instead of each partition maintaining a list of document IDs for the index entry <code>color:red</code>, only partition 0 maintains it. This helps to improve the performance when we need to scan a range of values using the color attribute. Yet, this approach adds up the complexity when writing, when we have multiple secondary indexes and each index partition, is placed on different partitions.</p>
</section>
</section>
<section id="rebalancing-partitions" class="level2">
<h2 class="anchored" data-anchor-id="rebalancing-partitions">Rebalancing Partitions</h2>
<p>No matter what rebalancing schemes are used, they should meet the following requirements:</p>
<ul>
<li><p>After rebalancing, the load queries should be distributed evenly across nodes.</p></li>
<li><p>While rebalancing is happening, the database should still accept reads and writes.</p></li>
<li><p>No more data than necessary should be moved between nodes to reduce network and disk I/O loads.</p></li>
</ul>
<section id="rebalancing-strategies" class="level3">
<h3 class="anchored" data-anchor-id="rebalancing-strategies">Rebalancing Strategies</h3>
<p>Strategies to assign partitions to nodes.</p>
<section id="hash-mod-n" class="level4">
<h4 class="anchored" data-anchor-id="hash-mod-n">Hash Mod N</h4>
<p>Hash the partition key and mod the value by N to decide the target node.</p>
<p><strong>Caveat:</strong></p>
<p>When adding new a node or reducing a failed node, most of the key will need to move to another node, which is expensive.</p>
</section>
<section id="fixed-number-of-partitions" class="level4">
<h4 class="anchored" data-anchor-id="fixed-number-of-partitions">Fixed number of partitions</h4>
<p>Define a fixed number of partitions at the beginning and distributed the partitions evenly to nodes. Whenever, the number of nodes changes, the number of partitions on each node will be changed, either increasing when removing a node or decreasing when adding a node.</p>
<p><strong>Caveat:</strong></p>
<p>It is hard to choose the “just right” number of partitions at the beginning.</p>
</section>
<section id="dynamic-number-of-partitions" class="level4">
<h4 class="anchored" data-anchor-id="dynamic-number-of-partitions">Dynamic number of partitions</h4>
<p>We config the min and max sizes of the partitions and use these numbers as the boundaries. Whenever the size of a partition is out of this boundary, we either split the partitions or merge them. In case of splitting, when a large dataset is split into 2 halves, one half will be sent to another node in the cluster. The advantage of this approach is that the number of partitions adapts to the total data volume.</p>
<p><strong>Caveat:</strong></p>
<p>The database is started with a single partition. Yet, it can be overcome by pre-splitting.</p>
</section>
<section id="partitioning-proportionally-to-nodes" class="level4">
<h4 class="anchored" data-anchor-id="partitioning-proportionally-to-nodes">Partitioning proportionally to nodes</h4>
<p>The number of partitions stays unchanged when the number of nodes remains. Yet, it increases or decreases when we add a new node or remove a failed node respectively.</p>
</section>
<section id="request-routing" class="level4">
<h4 class="anchored" data-anchor-id="request-routing">Request Routing</h4>
<p><img src="{{ site.baseurl }}/images/0f508f6930d682b8faa0a42fc4b67112ab413df8.png" title="Three different ways of routing a request to the right node" class="img-fluid"></p>
<p>In general, there are three approaches to routing a request to the correct node. No matter what approach we choose, the key challenge is how can we update the knowledge of partitions when the partitions move from one node to another node. Many distributed database systems rely on third-party coordination services like ZooKeeper to keep track of cluster metadata.</p>
<p><img src="{{ site.baseurl }}/images/0c28f90cd54f96892fbf0832a17ca34f07eeb0e9.png" title="Using ZooKeeper to keep track of assignment of partitions to nodes" class="img-fluid"></p>
<p>All the nodes and their partition mappings are registered in ZooKeeper. When there is a change in the mapping, ZooKeeper will notify the routing tier so that it can keep the routing information up to date.</p>
</section>
</section>
</section>
<section id="glossary" class="level2">
<h2 class="anchored" data-anchor-id="glossary">Glossary:</h2>
<p><strong>Shared-nothing architecture == horizontal scaling == scaling out</strong></p>
<p>In this architecture, each machine of the virtual machine running the database software is called a node. Each node uses its CPUs, RAM, and disks independently. Any coordination between nodes is done at the software level, using a conventional network.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/minhdang241\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>